 http状态码301和302详解及区别——辛酸的探索之路 https://blog.csdn.net/zhouchangshun_666/article/details/79354193

应用层（HTTP,FTP）、传输层（tcp/udp）、网络层(ip)、链路层

#### http 1.0/2.0/3.0  对比

1. Http 1.0

   - 短连接：每次发送请求都要重新建立tcp请求，即三次握手，性能较差
   - 无host头域：也就是http请求头里的host
   - 不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象

2. Http 1.1

   - **引入更多缓存策略**：在http 1.0 中主要使用header里的if-Modified-Since来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。
   - **在请求头引入range头域**：它允许只请求资源的某个部分，即返回码206，这样就方便了开发者自由的选择以便充分利用带宽和连接。
   - **Host头处理**：在Http1.0中认为每台服务器绑定一个唯一的IP 地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟机主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。Http1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host 头域会报404 Bad Request。
   - **长连接支持**：Http1.1支持长连接和请求的流水线（Pipelinling）处理，在一个TCP连接上可以传送多个Http请求（串行）和响应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启Connection: keep-alive，一定程度上弥补了Http1.0 每次请求都要创建连接的缺点。

3. Http 2.0 https://blog.csdn.net/yexudengzhidao/article/details/98207149

   - **新的二进制格式（Binary Format）**(二进制分帧)。HTTP1.x 的解析是基于文本。基于文本协议的格式存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑http2.0 的协议解析决定采用二进制格式，实现方便且健壮。

     为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。`在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。`

   - **多路复用**：即连接共享，一个连接上可以有多个request，一个request对应一个ID，每个连接的request可以随机的混杂在一起，接收方可以根据request的ID将request再归属到各自不同的服务端请求里面。

     > http2.0的多路复用和http1.1中的长连接复用有什么区别？
     >
     > http1.1 pipeling解决方式为：若干个请求排队串行化处理，后面的请求等待前面的请求返回才能获得执行机会，一旦有某个请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞（对头阻塞）。
     >
     > http2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接到正常执行。

   - **header压缩**，HTTP 1.x的header带有大量信息，而且每次都要重复传送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header field表，既避免了重复header的传输，又减少了需要传输的大小。

   - **服务端推送** 同SPDY（Google开发的基于tcp的会话层协议，对http的增强）一样，http2.0也具有server push功能

4. Http 3.0

   - 基于google的QUIC 协议，而quic协议是使用udp实现的减少了tcp三次握手时间，以及tls（安全传输层协议，用于在两个通信应用程序之间提供保密性和数据完整性）握手时间
   - 解决了http2.0中前一个stream丢包导致后一个stream被阻塞的问题（tcp层的队头阻塞）
   - 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
   - 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
   - 更合适的流量控制

**4. http3.0怎么解决udp的丢包问题？**

**答：** http3不仅仅只是简单将传输协议替换成了 UDP。还基于 UDP 协议在「应用层」实现了 QUIC 协议。它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。而且， QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。

**8. tcp是怎么保证数据传输的可靠性？**

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。

`1. 检验和`：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部

`2. 序列号/确认应答`: 只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。

在`使用窗口控制`中，如果出现段丢失，先考虑确认应答未能返回的情况。在这种情况下，数据已经到达 对端，是不需要再进行重发的。

然而，在`没有使用窗口控制`的时候，没有收到确认应答的数据都会被重发。其次考虑发送时丢失情况，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。

而发送端主机如果连续3次收到同一个确认应答、就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作`高速重发控制`。

`3. 流控制`： TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的`流控制`。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作`窗口大小`。

`4. 拥塞控制`： 如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入`慢启动机制`，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。

慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。

![image.png](https://segmentfault.com/img/bVcRUcf)

**9. tcp 传输的有序性**

发送主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。