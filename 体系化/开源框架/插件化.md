### 前言

插件化技术最初源于免安装运行apk的想法，这个免安装的apk就可以理解为插件，而支持插件的app我们一般叫宿主。宿主可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展

### 插件化的开源框架

插件化发展到现在，已经出现了非常多的框架，下表列出部分框架：

![image-20211213105043149](/Users/liujian/Documents/study/books/markdown/图片/image-20211213105043149.png)

我们在选择开源框架的时候，需要根据自身的需求来，如果加载的插件不需要和宿主又任何耦合，也无须与宿主通信，比如加载第三方app，那么推荐使用RePlugin，其他的情况推荐使用VirtualApk。

### 插件化的实现

我们如何去实现一个插件化呢？

首先我们要知道，插件apk是没有安装的，那我们怎么加载它呢？我们可以细分下，一个apk主要就是由代码和资源组成，所以上面的问题我们可以变为：如何加载插件的类？如何加载插件的资源？

然后我们还需要解决类的调用问题，这个地方主要是四大组件的调用问题。我们都知道，四大组件是需要注册的，而插件中的四大组件显然是没有注册，那我们怎么去调用呢？

所以我们接下来就是要解决这三个问题，从而实现插件化：

1、如何加载插件的类？

2、如何加载插件的资源？

3、如何调用插件的类？

### 类加载（ClassLoader）

我们在学Java的时候知道，Java源码文件编译后会生成一个class文件，而在Android中，将代码编译后会生成一个apk文件，将apk文件解压后就可以看到其中有一个活多个class.dex文件，它就是Android把所有class文件进行合并，优化后生成的。

Java中jvm加载的是class文件，而Android中DVM和ART加载的是dex文件，虽然二者都是用的ClassLoader加载的，但因为加载的文件类型不同，还是有些区别的，所以我们接下来主要介绍Android的ClassLoader是如何加载dex文件的。

####  ClassLoader的实现类

ClassLoader是一个抽象类，实现类主要分为两种类型：系统类加载器和自定义加载器。

其中系统类加载器主要包括三种：

- BootClassLoader

  用于加载Android FrameWork 层class文件。

- PathClassLoader

  用于Android应用程序类加载器。可以加载指定的dex，以及jar、zip、apk中的classes.dex

- DexClassLoader

  用于加载指定的dex，以及jar、zip、apk中的classes.dex

类继承关系如下：

​                 ![image-20211213111252692](/Users/liujian/Documents/study/books/markdown/图片/image-20211213111252692.png)

我们先来看下PathClassLoader和DexClassLoader。

```java
///libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java 
public class PathClassLoader extends BaseDexClassLoader{
  //optimizedDirectory直接为null 
  public PathClassLoader(String dexPath, ClassLoader parent){
    super(dexPath,null,null,parent);
  }
  //optimizedDirectory直接为null 
  public PathClassLoader(String dexPath,String librarySearchPath,ClassLoader parent){
    super(dexPath,null,librarySearchPath,parent);
  }
}

//API小于等于26/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java 
public class DexClassLoader extends BaseDexClassLoader{
  public DexClassLoader(String dexPath,String optimizedDirectory,
                        String librarySearchPath,ClassLoader parent){
    //26开始，super里面改变了，看下面两个构造方法
    super(dexPath,new File(optimizedDirectory),librarySearchPath,parent);
  }
}

//API26/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java
public BaseDexClassLoader(String dexPath,File optimizedDirectory,
                          String librarySearchPath,ClassLoaderparent){
  super(parent);
  //DexPathList的第四个参数是optimizedDirectory，可以看到这儿为null 
  this.pathList=new DexPathList(this,dexPath,librarySearchPath,null);
}

//API25/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java 
public BaseDexClassLoader(String dexPath,File optimizedDirectory,
                          String librarySearchPath,ClassLoader parent){
  super(parent);
  this.pathList=new DexPathList(this,dexPath,librarySearchPath,optimizedDirectory);
}
```

根据源码了解到，PathClassLoader和DexClassLoader 都是继承自BaseDexClassLoader，且类中只有构造方法，它们的类加载逻辑完全写在BaseDexClassLoader中。

其中我们值得注意的是，在8.0之前，它们二者的唯一区别是第二个参数optimizedDirectory，这个参数的意思是生成的odex（优化的dex）存放的路径，PathClassLoader直接为null，而DexClassLoader是使用用户传进来的路径，而在8.0之后，二者就完全一样了。

下面我们再来了解下BootClassLoader和PathClassLoader之间的关系。

```java
//在onCreate中执行下面代码
ClassLoader classLoader = getClassLoader();
while(classLoader!=null){
  Log.e("aa","classLoader:"+classLoader);
  classLoader = classLoader.getParent();
}
Log.e("aa","classLoader:"+Activity.class.getClassLoader());
```

打印结果：

```
classLoader:dalvik.system.PathClassLoader[DexPathList[[zipfile 
"/data/user/0/com.enjoy.pluginactivity/cache/plugin-debug.apk",zipfile 
"/data/app/com.enjoy.pluginactivity-T4YwTh-
8gHWWDDS19IkHRg==/base.apk"],nativeLibraryDirectories=[/data/app/com.enjoy.pluginactivity-T4YwTh-8gHWWDDS19IkHRg==/lib/x86_64,/system/lib64,/vendor/lib64]]]
classLoader:java.lang.BootClassLoader@a26e88d 
classLoader:java.lang.BootClassLoader@a26e88d
```

通过打印结果可知，应用程序类是由PathClassLoader加载的，Activity类是BootClassLoader加载的，并且BootClassLoader是PathClassLoader的parent，这里要注意parent与父类的区别。这个打印结果我们下面还会提到。

#### 加载原理

那我们如何使用类加载器去加载一个类呢？
非常简单，类如：我们有一个apk文件，路径是apkPath，然后里面有个类com.enjoy.plugin.Test，那么我们可以通过如下方法去加载Test类：

```java
DexClassLoader dexClassLoader = new DexClassLoader(dexPath,context.getCacheDir().getAbsolutePath(), null, context.getClassLoader());
Class<?> clazz = dexClassLoader.loadClass("com.enjoy.plugin.Test");                                          
```

因为我们需要将插件的dex文件加载到宿主里面，所以我们接下来分析源码，看DexClassLoader类加载器到底是怎么加载一个apk的dex文件的。

通过查找发现，DexClassLoader类中没有loadClass方法，一路向上查找，最后在ClassLoader类中找到了该方法，源码如下：