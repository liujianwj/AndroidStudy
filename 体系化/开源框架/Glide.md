1、生命周期管理

- 在子线程中，或者传入的context为application，则不会创建空白fragment去感知生命周期，而是跟随整个应用的开始和结束，所以无法释放资源，因避免这种使用。

- 如何保证每个activity都有唯一fragment？显示通过tag获取，然后在查看缓存列表，再post一条消息。

  原因：FragmentManager的commit方法内部是通过handler消息处理的，所以是异步的，无法直接通过tag获取来保证唯一，所以通过直接添加到缓存列表来进一步判断处理。然后通过post消息，保证commit后，从缓存列表移除。

2、缓存

- 内存缓存为什么需两层（活动缓存、LRU内存缓存）？

  因为LRU内存缓存可能存在，当缓存满了的时候，会去删除及释放缓存数据，为了避免被删除的缓存数据正在使用而导致的问题，增加一个活动缓存。活动缓存是没有数量限制，使用弱引用处理，上层消费先从LRU内存缓存中查找，如果找到，则先将数据移动到活动缓存再使用，当使用完后，会重新移回LRU内存缓存。这样就保证了每次在使用的时候，数据都是在活动缓存中，避免了LRU内存缓存的问题。

