状态机+回调，

suspend为标识，这样在编译器的时候，会自动去做代码处理，完成状态机+回调的实现，当遇到内部调用挂起方法时，则会增加一个状态label，将后续的代码放到下一个label判断中等待调用

先有状态，回调与平时线程切换访问网络，传入callback，网络请求结束，切换线程调用callback处理结果的作用是一样的，区别在于，用状态机的方式，将异步代码用同步的方式完成。

```kotlin
suspend fun test(): Int{
    return 11
}

fun main(){

    GlobalScope.launch(Dispatchers.Main) {
        val aaa = "121"

        val bbb = withContext(Dispatchers.IO){
            return@withContext test()
        }

        print( aaa + bbb)
    }

}
```

反编译后代码

```java
public final class CoroutinesTestKt {
   @Nullable
   public static final Object test(@NotNull Continuation $completion) {
      return Boxing.boxInt(11);
   }

   public static final void main() {
      BuildersKt.launch$default((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)Dispatchers.getMain(), (CoroutineStart)null, (Function2)(new Function2((Continuation)null) {
         Object L$0;
         int label; //初始值默认为0

         @Nullable
         public final Object invokeSuspend(@NotNull Object $result) {
            //标识为挂起
            Object var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
            Object var10000;
            String aaa;
            switch(this.label) {
            case 0:
               ResultKt.throwOnFailure($result);
               aaa = "121";
               CoroutineContext var7 = (CoroutineContext)Dispatchers.getIO();
               Function2 var10001 = (Function2)(new Function2((Continuation)null) {
                  int label;

                  @Nullable
                  public final Object invokeSuspend(@NotNull Object $result) {
                     Object var2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
                     Object var10000;
                     switch(this.label) {
                     case 0:
                        ResultKt.throwOnFailure($result);
                        this.label = 1;
                        var10000 = CoroutinesTestKt.test(this);
                         //此时var10000已经获取到真实的值，!=var2，无需再挂起，直接返回var10000
                         //上层拿到var10000，发现不是挂起，则切换回原来的线程
                         //执行之前传进来的callback.invokeSuspends(result)将var10000传出去
                        if (var10000 == var2) {
                           return var2;
                        }
                        break;
                     case 1:
                        ResultKt.throwOnFailure($result);
                        var10000 = $result;
                        break;
                     default:
                        throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
                     }

                     return var10000;
                  }

                  @NotNull
                  public final Continuation create(@Nullable Object value, @NotNull Continuation completion) {
                     Intrinsics.checkNotNullParameter(completion, "completion");
                     Function2 var3 = new <anonymous constructor>(completion);
                     return var3;
                  }

                  public final Object invoke(Object var1, Object var2) {
                     return ((<undefinedtype>)this.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);
                  }
               });
               this.L$0 = aaa;
               this.label = 1;
               //这里会去切换线程，将this(callback)传入，
               //子线程完成任务后切换原来线程并调用this.invokeSuspends(result)执行label == 1逻辑
               var10000 = BuildersKt.withContext(var7, var10001, this);
               //如果需要切换线程，则var10000会==var6，此时为挂起
               //需要等待下一次invokeSuspend执行
               if (var10000 == var6) {
                  return var6;
               }
               break;
            case 1:
               aaa = (String)this.L$0;
               ResultKt.throwOnFailure($result);
               var10000 = $result;
               break;
            default:
               throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
            }

            int bbb = ((Number)var10000).intValue();
            String var4 = aaa + bbb;
            boolean var5 = false;
            System.out.print(var4);
            return Unit.INSTANCE;
         }

         @NotNull
         public final Continuation create(@Nullable Object value, @NotNull Continuation completion) {
            Intrinsics.checkNotNullParameter(completion, "completion");
            Function2 var3 = new <anonymous constructor>(completion);
            return var3;
         }

         public final Object invoke(Object var1, Object var2) {
            return ((<undefinedtype>)this.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);
         }
      }), 2, (Object)null);
   }

   // $FF: synthetic method
   public static void main(String[] var0) {
      main();
   }
}

```

